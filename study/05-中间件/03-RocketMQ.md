# RocketMQ

推荐学习的四个网站：
主要来源：rocketmq官网一https://rocketmq.apache.org/（官网是最值得学习的老师，我只做知识的讲述者）
社区网站：https://rocketmq-learning.com
GitHub：https://github.com/apache/rocketmq
阿里云：https://www.aliyun.com/product/rocketmq

## 通信方式

同步RPC调用模型![同步调用](..\img\syncarchi-ebbd41e1afd6adf432792ee2d7a91748.png)

异步通信模型![异步调用](..\img\asyncarchi-e7ee18dd77aca472fb80bb2238d9528b.png)

**RPC是一种同步的通信方式**，即客户端调用远程服务时，需要等待服务端响应才能继续执行。RPC通常使用 HTTP、HTTPS、TCP等协议进行通信，可以实现高性能、高可用和高并发。RPC适用于需要大量数据传输、需要 保证数据一致性的场景，例如金融、电商等。 

**MQ是一种异步的通信方式**，即客户端将消息发送到MQ队列中，服务端可以从队列中获取消息进行处理。MQ适 用于需要异步处理、解耦、流量控制等场景，例如日志、监控、报警等。MQ适用于高吞吐量、低延迟、可扩展性 强的场景。

总结来说，RPC适用于需要同步调用的场景，而MQ适用于需要异步处理、解耦、流量控制的场景。在实际应用
中，需要根据业务需求和系统特点来选择合适的通信方式。

针对以上两种通信方式，我们分别列举几个列子：

**RPC同步通信场景：**

1. 在网银转账时，需要将收款人和付款人的账户信息进行验证，并进行转账操作。在这个场景中，网银系统可以
   提供转账API，客户端在调用转账API时，需要等待转账完成才能继续执行后续操作，这类似于RPC同步通信。
2. 在游戏中的组队系统中，需要将玩家加入到队伍中，并协调队伍成员之间的操作。在这个场景中，游戏系统提
   供了加入队伍的API，客户端在调用该API时需要等待加入队伍的结果，这类似于RPC同步通信。

**MQ异步通信场景：**

1. 在电商系统中，当用户下单后，系统需要将订单信息发送给物流系统进行配送。在这个场景中，电商系统可以
   将订单信息作为消息发布到MQ队列中，物流系统从MQ队列中订阅该消息并进行配送操作。由于配送操作是
   异步进行的，客户端不需要等待配送完成就可以继续执行后续操作，这类似于MQ异步通信。
2. 在社交系统中，当用户发布一条消息时，系统需要将该消息推送给其他用户。在这个场景中，社交系统可以将
   该消息作为消息发布到MQ队列中，其他用户从MQ队列中订阅该消息并进行查看操作。由于查看操作是异步
   进行的，客户端不需要等待消息推送完成就可以继续执行后续操作，这类似于MQ异步通信。

## 消息传输模型

点对点模型 ![点对点模型](..\img\p2pmode-fefdc2fbe4792e757e26befc0b3acbff.png)

点对点模型也叫队列模型，具有如下特点：

- 消费匿名：消息上下游沟通的唯一的身份就是队列，下游消费者从队列获取消息无法申明独立身份。
- 一对一通信：基于消费匿名特点，下游消费者即使有多个，但都没有自己独立的身份，因此共享队列中的消息，每一条消息都只会被唯一一个消费者处理。因此点对点模型只能实现一对一通信。

发布订阅模型 ![发布订阅模型](..\img\pubsub-042a4e5e5d76806943bd7dcfb730c5d5.png)

发布订阅模型具有如下特点：

- 消费独立：相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。
- 一对多通信：基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。

传输模型对比

点对点模型和发布订阅模型各有优势，点对点模型更为简单，而发布订阅模型的扩展性更高。 Apache RocketMQ 使用的传输模型为发布订阅模型，因此也具有发布订阅模型的特点。

## 领域模型

### 主题（Topic）

#### 使用建议

**按照业务分类合理拆分主题**

Apache RocketMQ 的主题拆分设计应遵循大类统一原则，即将相同业务域内同一功能属性的消息划分为同一主题。拆分主题时，您可以从以下角度考虑拆分粒度：

- 消息类型是否一致：不同类型的消息，如顺序消息和普通消息需要使用不同的主题。
- 消息业务是否关联：如果业务没有直接关联，比如，淘宝交易消息和盒马物流消息没有业务交集，需要使用不同的消息主题；同样是淘宝交易消息，女装类订单和男装类订单可以使用同一个订单。当然，如果业务量较大或其他子模块应用处理业务时需要进一步拆分订单类型，您也可以将男装订单和女装订单的消息拆分到两个主题中。
- 消息量级是否一样：数量级不同或时效性不同的业务消息建议使用不同的主题，例如某些业务消息量很小但是时效性要求很强，如果跟某些万亿级消息量的业务使用同一个主题，会增加消息的等待时长。

**正确拆分示例：** 线上商品购买场景下，订单交易如订单创建、支付、取消等流程消息使用一个主题，物流相关消息使用一个主题，积分管理相关消息使用一个主题。

**错误拆分示例：**

- 拆分粒度过粗：会导致业务隔离性差，不利于独立运维和故障处理。例如，所有交易消息和物流消息都共用一个主题。
- 拆分粒度过细：会消耗大量主题资源，造成系统负载过重。例如，按照用户ID区分，每个用户ID使用一个主题。

**单一主题只收发一种类型消息，避免混用**

Apache RocketMQ 主题的设计原则为通过主题隔离业务，不同业务逻辑的消息建议使用不同的主题。同一业务逻辑消息的类型都相同，因此，对于指定主题，应该只收发同一种类型的消息。

**主题管理尽量避免自动化机制**

在 Apache RocketMQ 架构中，主题属于顶层资源和容器，拥有独立的权限管理、可观测性指标采集和监控等能力，创建和管理主题会占用一定的系统资源。因此，生产环境需要严格管理主题资源，请勿随意进行增、删、改、查操作。

Apache RocketMQ 虽然提供了自动创建主题的功能，但是建议仅在测试环境使用，生产环境请勿打开，避免产生大量垃圾主题，无法管理和回收并浪费系统资源。

### 队列（MessageQueue）

#### 使用建议

**按照实际业务消耗设置队列数**

Apache RocketMQ 的队列数可在创建主题或变更主题时设置修改，队列数量的设置应遵循少用够用原则，避免随意增加队列数量。

主题内队列数过多可能对导致如下问题：

- 集群元数据膨胀

  Apache RocketMQ 会以队列粒度采集指标和监控数据，队列过多容易造成管控元数据膨胀。

- 客户端压力过大

  Apache RocketMQ 的消息读写都是针对队列进行操作，队列过多对应更多的轮询请求，增加系统负荷。

**常见队列增加场景**

- 需要增加队列实现物理节点负载均衡

  Apache RocketMQ 每个主题的多个队列可以分布在不同的服务节点上，在集群水平扩容增加节点后，为了保证集群流量的负载均衡，建议在新的服务节点上新增队列，或将旧的队列迁移到新的服务节点上。

- 需要增加队列实现顺序消息性能扩展

  在 Apache RocketMQ 服务端4.x版本中，顺序消息的顺序性在队列内生效的，因此顺序消息的并发度会在一定程度上受队列数量的影响，因此建议仅在系统性能瓶颈时再增加队列。

### 消息（Message）

消息不可变性 一旦产生消息内容不会发生改变   消息持久化  默认对消息持久化  可回溯性 可回复性

#### 使用建议

**单条消息不建议传输超大负载**

作为一款消息中间件产品，Apache RocketMQ 一般传输的是都是业务事件数据。单个原子消息事件的数据大小需要严格控制，如果单条消息过大容易造成网络传输层压力，不利于异常重试和流量控制。

生产环境中如果需要传输超大负载，建议按照固定大小做报文拆分，或者结合文件存储等方法进行传输。

**消息中转时做好不可变设计**

Apache RocketMQ 服务端5.x版本中，消息本身不可编辑，消费端获取的消息都是只读消息视图。 但在历史版本3.x和4.x版本中消息不可变性没有强约束，因此如果您需要在使用过程中对消息进行中转操作，务必将消息重新初始化。

### 生产者（Producer）

#### 使用建议

**不建议单一进程创建大量生产者**

Apache RocketMQ 的生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。

**不建议频繁创建和销毁生产者**

Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。

### 消费者分组（ConsumerGroup）

#### 使用建议

**按照业务合理拆分分组**

Apache RocketMQ 的消费者和主题是多对多的关系，对于消费者分组的拆分设计，建议遵循以下原则：

- 消费者的投递顺序一致：同一消费者分组下所有消费者的消费投递顺序是相同的，统一都是顺序投递或并发投递，不同业务场景不能混用消费者分组。
- 消费者业务类型一致：一般消费者分组和主题对应，不同业务域对消息消费的要求不同，例如消息过滤属性、消费重试策略不同。因此，不同业务域主题的消费建议使用不同的消费者分组，避免一个消费者分组消费超过10个主题。

**消费者分组管理尽量避免自动化机制**

在 Apache RocketMQ 架构中，消费分组属于状态管理类的逻辑资源，每个消费分组都会涉及关联的消费状态、堆积信息、可观测指标和监控采集数据。因此，生产环境需要严格管理消费者分组资源，请勿随意进行增、删、改、查操作。

Apache RocketMQ 虽然提供了自动创建消费者分组的功能，但是建议仅在测试环境使用，生产环境请勿打开，避免产生大量消费者分组，无法管理和回收，且浪费系统资源。

### 消费者（Consumer）

#### 使用建议

**不建议在单一进程内创建大量消费者**

Apache RocketMQ 的消费者在通信协议层面支持非阻塞传输模式，网络通信效率较高，并且支持多线程并发访问。因此，大部分场景下，单一进程内同一个消费分组只需要初始化唯一的一个消费者即可，开发过程中应避免以相同的配置初始化多个消费者。

**不建议频繁创建和销毁消费者**

Apache RocketMQ 的消费者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次接收消息时动态创建消费者，且在消费完成后销毁消费者。这样频繁地创建销毁会在服务端产生大量短连接请求，严重影响系统性能。

### 订阅关系（Subscription）

#### 使用建议

**建议不要频繁修改订阅关系**

在 Apache RocketMQ 领域模型中，订阅关系关联了过滤规则、消费进度等元数据和相关配置，同时系统需要保证消费者分组下的所有消费者的消费行为、消费逻辑、负载策略等一致，整体运算逻辑比较复杂。因此，不建议在生产环境中通过频繁修改订阅关系来实现业务逻辑的变更，这样可能会导致客户端一直处于负载均衡调整和变更的过程，从而影响消息接收。

## 环境搭建

RocketMQ针对不同场景给我们提供了几组样例配置

* 2m-2s-async
* 2m-2s-sync
* 2m-noslave

![PixPin_2025-04-13_21-48-27](..\img\PixPin_2025-04-13_21-48-27.png)

```sh
# loacl方式集群（broker和proxy启动在一起）
## 2m-noslave 2master无slave
### 启动第一个Master，-n代表nameser，nameser也可以在配置文件中配置
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
noslave/broker-a.properties --enable-proxy &
### 启动第二个Master
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
noslave/broker-b.properties --enable-proxy &

## 2m-2s-async
### 启动第一个Master
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
2s-async/broker-a.properties --enable-proxy &
### 启动第二个Master
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
2s-async/broker-b.properties --enable-proxy &
### 启动第一个Slave
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
2s-async/broker-a-s.properties --enable-proxy &
### 启动第二个Slave
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
2s-async/broker-b-s.properties --enable-proxy &

# cluster集群模式（broker和proxy启动在不同的机器）
## 2m-noslave
### 启动第一个Master
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
noslave/broker-a.properties &
### 启动第二个Master
nohup sh bin/mqbroker -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' -c conf/2m-
noslave/broker-b.properties &
### 启动第一个Master的proxy
nohup sh bin/mqproxy -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' &
### 启动第二个Master的proxy
nohup sh bin/mqproxy -n
'192.168.169.129:9876;192,168.169.130:9876;192.168.169.131:9876' &
```

## Java中发送消息

[在Java中使用rocketmq](https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/)

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>5.0.7</version>
</dependency>
```

