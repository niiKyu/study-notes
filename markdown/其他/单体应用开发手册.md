# idea开发手册

## 项目设置

编码![PixPin_2025-04-29_19-10-32](..\img\PixPin_2025-04-29_19-10-32.png)

仓库![PixPin_2025-04-29_19-10-55](..\img\PixPin_2025-04-29_19-10-55.png)

jdk![image-20250515103122473](..\img\image-20250515103122473.png)

## pom.xml

### jdk21

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.5</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>

<properties>
    <java.version>21</java.version>
    <maven.compiler.source>21</maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <java.version>21</java.version>
    <fastjson2.version>2.0.56</fastjson2.version>
    <lombok.version>1.18.36</lombok.version>
    <mybatis-spring-boot-starter.version>3.0.4</mybatis-spring-boot-starter.version>
    <mysql-connector-j.version>8.3.0</mysql-connector-j.version>
</properties>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
<version>${mybatis-spring-boot-starter.version}</version>
</dependency>
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
<version>${fastjson2.version}</version>
</dependency>
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2-extension-spring5</artifactId>
<version>${fastjson2.version}</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
<version>${mysql-connector-j.version}</version>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
<version>${lombok.version}</version>
</dependency>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

<repositories>
    <repository>
        <id>public</id>
        <name>aliyun nexus</name>
        <url>https://maven.aliyun.com/repository/public</url>
        <releases>
            <enabled>true</enabled>
        </releases>
    </repository>
</repositories>
```

### jdk11

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.18</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>

<properties>
    <java.version>11</java.version>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

    <fastjson2.version>2.0.56</fastjson2.version>
    <mybatis-spring-boot-starter.version>2.3.2</mybatis-spring-boot-starter.version>
    <mysql-connector-j.version>8.3.0</mysql-connector-j.version>
    <lombok.version>1.18.36</lombok.version>
</properties>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
<version>${mybatis-spring-boot-starter.version}</version>
</dependency>
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
<version>${fastjson2.version}</version>
</dependency>
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2-extension-spring5</artifactId>
<version>${fastjson2.version}</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
<version>${mysql-connector-j.version}</version>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
<version>${lombok.version}</version>
</dependency>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

<repositories>
    <repository>
        <id>public</id>
        <name>aliyun nexus</name>
        <url>https://maven.aliyun.com/repository/public</url>
        <releases>
            <enabled>true</enabled>
        </releases>
    </repository>
</repositories>
```

## config

### AppConfig

```java
@Configuration
// 开启aop
//@EnableAspectJAutoProxy
// 开启事务
//@EnableTransactionManagement
// mybatis扫包，发现mapper
@MapperScan("com.ydlclass.activitidemo2.dao")
//@EnableAsync
public class AppConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
}
```

### RedisConfig

```java
@Configuration
public class RedisConfig {
    @Bean
    @SuppressWarnings(value = { "unchecked", "rawtypes"})
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);

//        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
        redisTemplate.setDefaultSerializer(new GenericFastJsonRedisSerializer());//设置默认的Serialize，包含 keySerializer & valueSerializer

        //redisTemplate.setKeySerializer(fastJsonRedisSerializer);//单独设置keySerializer
        //redisTemplate.setValueSerializer(fastJsonRedisSerializer);//单独设置valueSerializer
        return redisTemplate;
    }
}
```

### SecurityConfig

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Resource
    LoginFilter loginFilter;

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        String[] allowedPaths = { "/login", "/register", "/css/**", "/js/**", "/img/**" };
        AuthenticatedAuthorizationManager<Object> objectAuthenticatedAuthorizationManager = new AuthenticatedAuthorizationManager<>();

        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                // 前后端分离架构不需要csrf保护
                .csrf((csrf) -> csrf.disable())
                // 禁用默认登录页
                .formLogin((login) -> login.disable())
                // 禁用默认登出页
                .logout((logout) -> logout.disable())
                // 禁用basic明文验证
                .httpBasic((basic) -> basic.disable())
                // 前后端分离是无状态的，不需要session了，直接禁用
                .sessionManagement(configurer -> configurer
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                        //设置用户只允许在一处登录，挤掉已登录用户
                        .maximumSessions(1)
                )
                // 注册登录过滤器，阻止非系统用户访问
                .addFilterBefore(loginFilter, UsernamePasswordAuthenticationFilter.class)
                .authorizeHttpRequests(authorize -> authorize
                        // permitAll放行、anonymous未登录才能访问、authenticated登录才能访问
                        .requestMatchers(allowedPaths).anonymous()
                        // 除上面外的所有请求全部需要鉴权认证
                        .anyRequest().authenticated()
                );


        return http.build();


//        // 设置异常的EntryPoint，如果不设置，默认使用Http403ForbiddenEntryPoint
//        .exceptionHandling(exceptions -> exceptions.authenticationEntryPoint(invalidAuthenticationEntryPoint))
//        // 前后端分离是无状态的，不需要session了，直接禁用。
//        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
//        .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests
//                // 允许所有OPTIONS请求
//                .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
//                // 允许直接访问授权登录接口
//                .requestMatchers(HttpMethod.POST, "/web/authenticate").permitAll()
//                // 允许 SpringMVC 的默认错误地址匿名访问
//                .requestMatchers("/error").permitAll()
//                // 其他所有接口必须有Authority信息，Authority在登录成功后的UserDetailsImpl对象中默认设置“ROLE_USER”
//                //.requestMatchers("/**").hasAnyAuthority("ROLE_USER")
//                // 允许任意请求被已登录用户访问，不检查Authority
//                .anyRequest().authenticated())
//        .authenticationProvider(authenticationProvider())
//        // 加我们自定义的过滤器，替代UsernamePasswordAuthenticationFilter
//        .addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

    }

    /**
     * 配置跨源访问(CORS)
     * @return
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedHeaders(Collections.singletonList("*"));
        configuration.setAllowedMethods(Collections.singletonList("*"));
        configuration.setAllowedOrigins(Collections.singletonList("*"));
        configuration.setMaxAge(3600L);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

### WebConfig

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**").allowedMethods("*").allowedOrigins("*");
    }
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //        调用父类的配置
        WebMvcConfigurer.super.configureMessageConverters(converters);

        //升级最新版本需加=============================================================
        List<MediaType> supportedMediaTypes = new ArrayList<>();
        supportedMediaTypes.add(MediaType.APPLICATION_JSON);
        supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);
        supportedMediaTypes.add(MediaType.APPLICATION_ATOM_XML);
        supportedMediaTypes.add(MediaType.APPLICATION_FORM_URLENCODED);
        supportedMediaTypes.add(MediaType.APPLICATION_OCTET_STREAM);
        supportedMediaTypes.add(MediaType.APPLICATION_PDF);
        supportedMediaTypes.add(MediaType.APPLICATION_RSS_XML);
        supportedMediaTypes.add(MediaType.APPLICATION_XHTML_XML);
        supportedMediaTypes.add(MediaType.APPLICATION_XML);
        supportedMediaTypes.add(MediaType.IMAGE_GIF);
        supportedMediaTypes.add(MediaType.IMAGE_JPEG);
        supportedMediaTypes.add(MediaType.IMAGE_PNG);
        supportedMediaTypes.add(MediaType.TEXT_EVENT_STREAM);
        supportedMediaTypes.add(MediaType.TEXT_HTML);
        supportedMediaTypes.add(MediaType.TEXT_MARKDOWN);
        supportedMediaTypes.add(MediaType.TEXT_PLAIN);
        supportedMediaTypes.add(MediaType.TEXT_XML);

        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
        fastJsonHttpMessageConverter.setSupportedMediaTypes(supportedMediaTypes);
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setWriterFeatures(JSONWriter.Feature.WriteMapNullValue, JSONWriter.Feature.WriteByteArrayAsBase64, JSONWriter.Feature.BrowserSecure);

        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
//        将 fastjson 添加到视图消息转换器列表内
        converters.add(fastJsonHttpMessageConverter);
    }

}
```

## constant

### RedisTokenConstant

```java
public class RedisTokenConstant {

    /**
     * token的key前缀
     */
    public static final String TOKEN_PREFIX = "token:";

    /**
     * 获取token的header key
     */
    public static final String HTTP_HEADER_AUTHORIZATION = "Authorization";
    /**
     * token过期时间
     */
    public static final long TOKEN_TIME = 1800L;

    /**
     * 防止表单重复提交的key前缀
     */
    public static final String REPEAT_PREFIX = "repeat:";

}
```

## security

### LoginFilter

```java
@Component
public class LoginFilter extends OncePerRequestFilter {
    @Resource
    RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 1、获取token
        String token = request.getHeader(RedisTokenConstant.HTTP_HEADER_AUTHORIZATION);
        if (token == null) {
            // 如果获取不到直接放行，不做认证
            filterChain.doFilter(request,response);
            return;
        }

        // 2、从redis获取登录用户
        YdlLoginUser ydlLoginUser = RedisTokenUtil.getLoginUser(redisCache, request);
        // 如果找不到，用户登录过期
        if (ydlLoginUser == null) {
            throw new UserLoginExpireException();
        }

        // 3、如果找到，说明当前用户正在使用系统，给该用户token续命
        YdlUser ydlUser = ydlLoginUser.getYdlUser();
        Long userId = ydlUser.getUserId();
        redisCache.expire(RedisTokenConstant.TOKEN_PREFIX + userId, RedisTokenConstant.TOKEN_TIME, TimeUnit.SECONDS);

        // 4、存入SecurityContextHolder
        UsernamePasswordAuthenticationToken authenticationToken =
                new UsernamePasswordAuthenticationToken(ydlUser.getUserName(), null, ydlLoginUser.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        // 存入activiti权限
        org.activiti.engine.impl.identity.Authentication.setAuthenticatedUserId(ydlUser.getUserName());

        // 5、放行
        filterChain.doFilter(request,response);
    }
}
```

### UserDetailsServiceImpl

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Resource
    YdlUserDao userDao;
    @Resource
    RestTemplate restTemplate;
    @Resource
    RedisCache redisCache;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、从数据库查询用户信息
        YdlUser ydlUser = userDao.queryByUserName(username);
        if (Objects.isNull(ydlUser)) {
            throw new UserNotFoundException(username);
        }

        Long userId = ydlUser.getUserId();
        YdlLoginUser.YdlLoginUserBuilder builder = YdlLoginUser.builder().userId(userId);
        // 2、从数据库查询用户权限信息
        YdlUser info = userDao.getInfo(userId);
        List<YdlRole> ydlRoles = ydlUser.getRoles();
        List<String> roles = ydlRoles.stream().map(YdlRole::getRoleTag).collect(Collectors.toList());
        List<String> perms = new ArrayList<>();
        ydlRoles.forEach(ydlRole -> {
            ydlRole.getMenus().forEach(ydlMenu -> {
                perms.add(ydlMenu.getPerms());
            });
        });
        builder.roles(roles)
                .perms(perms);

        // 3、获取登录信息
        HttpServletRequest request = RedisTokenUtil.getRequest();
        UserAgent userAgent = new UserAgent(request.getHeader("User-Agent"));
        // 通过ip获取其所属的地址
        ResponseEntity<String> result = restTemplate.getForEntity("https://whois.pconline.com.cn/ipJson.jsp?ip="+request.getRemoteHost()+"&json=true", String.class);
        String body = result.getBody();
        Map<String,String> map = JSONObject.parseObject(body, new TypeReference<>() {});
        String location = map.get("addr")+map.get("pro")+map.get("city")+map.get("region");
        builder.loginTime(new Date())
                .ipaddr(request.getRemoteAddr())
                .os(userAgent.getOperatingSystem().getName())
                .browser(userAgent.getBrowser().getName())
                .loginLocation(location);

        // 4、创建jwt，将用户id存入，让前端每次请求都带上jwt
        String jwt = JwtUtil.createJwt(new HashMap<>(){{
            put(JwtClaimsConstant.USER_ID,userId);
        }});
        builder.token(jwt);

        YdlLoginUser ydlLoginUser = builder.build();
        // 5、登录用户存入redis
        RedisTokenUtil.saveLoginUser(userId,ydlLoginUser,redisCache);

        return ydlLoginUser;
    }
}
```

### YdlLoginUser

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class YdlLoginUser implements UserDetails {

    private YdlUser ydlUser;

    private List<String> roles;

    private List<String> perms;

    /**
     * 用户ID
     */
    private Long userId;
    /**
     * 用户唯一标识
     */
    private String token;
    /**
     * 登录时间
     */
    private Date loginTime;
    /**
     * 登录IP地址
     */
    private String ipaddr;

    /**
     * 登录地点
     */
    private String loginLocation;
    /**
     * 浏览器类型
     */
    private String browser;
    /**
     * 操作系统
     */
    private String os;


    @JSONField(serialize = false)
    private List<GrantedAuthority> authorities;

    public YdlLoginUser(YdlUser ydlUser, List<String> roles, List<String> perms) {
        this.ydlUser = ydlUser;
        this.roles = roles;
        this.perms = perms;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        if (Objects.nonNull(authorities)) {
            return authorities;
        }

        if (Objects.nonNull(perms)) {
            authorities = perms.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
            authorities.addAll(roles.stream().map(role -> new SimpleGrantedAuthority("ROLE_"+role)).collect(Collectors.toList()));
            authorities.addAll(roles.stream().map(role -> new SimpleGrantedAuthority("GROUP_"+role)).collect(Collectors.toList()));
        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return ydlUser.getPassword();
    }

    @Override
    public String getUsername() {
        return ydlUser.getUserName();
    }
}
```

## service

### YdlUserServiceImpl

```java
@Service("ydlUserService")
public class YdlUserServiceImpl implements YdlUserService {
    @Resource
    private YdlUserDao ydlUserDao;
    @Resource
    AuthenticationManager authenticationManager;
    @Resource
    RedisCache redisCache;


    public YdlLoginUser login(String username, String password) {
        // 1、认证
        Authentication authenticate = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        // 2、如果认证没通过，给出对应的提示
        if (Objects.isNull(authenticate)) {
            throw new PasswordIncorrectException(username);
        }
        // 3、认证通过，拿到登录实例
        YdlLoginUser ydlLoginUser = (YdlLoginUser) authenticate.getPrincipal();

        // 4、返回给前端
        return ydlLoginUser;
    }

    public void logout(){
        // 删除redis的登录用户
        Integer id = RedisTokenUtil.getUserId();
        redisCache.deleteObject(RedisTokenConstant.TOKEN_PREFIX + id);
    }
}
```

## util

### RedisCache

```java
@SuppressWarnings(value = { "unchecked", "rawtypes" })
@Component
public class RedisCache
{
    @Autowired
    public RedisTemplate redisTemplate;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     */
    public <T> void setCacheObject(final String key, final T value)
    {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     * @param timeout 时间
     * @param timeUnit 时间颗粒度
     */
    public <T> void setCacheObject(final String key, final T value, final long timeout, final TimeUnit timeUnit)
    {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout)
    {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @param unit 时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit)
    {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public <T> T getCacheObject(final String key)
    {
        ValueOperations<String, T> operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key)
    {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection)
    {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key 缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public <T> long setCacheList(final String key, final List<T> dataList)
    {
        return redisTemplate.opsForList().rightPushAll(key, dataList);
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public <T> List<T> getCacheList(final String key)
    {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key 缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)
    {
        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);
        Iterator<T> it = dataSet.iterator();
        while (it.hasNext())
        {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public <T> Set<T> getCacheSet(final String key)
    {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)
    {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public <T> Map<String, T> getCacheMap(final String key)
    {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @param value 值
     */
    public <T> void setCacheMapValue(final String key, final String hKey, final T value)
    {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public <T> T getCacheMapValue(final String key, final String hKey)
    {
        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     *
     * @param key
     * @param hkey
     */
    public void delCacheMapValue(final String key, final String hkey)
    {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hkey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)
    {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection<String> keys(final String pattern)
    {
        return redisTemplate.keys(pattern);
    }
}
```

### RedisTokenUtil

```java
public class RedisTokenUtil {

    /**
     * 从ThreadLocal中获取当前http请求
     * @return
     */
    public static HttpServletRequest getRequest(){
        return  ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
    }

    /**
     * // 获取token中的userId
     * @return 用户id
     */
    public static Integer getUserId() {
        return getUserId(null);
    }
    /**
     * // 获取token中的userId
     * @return 用户id
     */
    public static Integer getUserId(HttpServletRequest request) {
        String token = (Objects.isNull(request) ? getRequest() : request).getHeader(RedisTokenConstant.HTTP_HEADER_AUTHORIZATION);
        if (Objects.isNull(token)) return null;
        Claims claims = JwtUtil.parseJWT(token);
        return (Integer) claims.get(JwtClaimsConstant.USER_ID);
    }

    /**
     * 从redis中获取登录用户
     * @param redisCache
     * @return
     */
    public static YdlLoginUser getLoginUser(RedisCache redisCache) {
        return getLoginUser(redisCache,null);
    }
    /**
     * 从redis中获取登录用户
     * @param redisCache
     * @param request
     * @return
     */
    public static YdlLoginUser getLoginUser(RedisCache redisCache, HttpServletRequest request) {
        // 1、获取token中的userId
        Integer userId = getUserId(request);
        // 如果获取不到，用户未登录
        if (userId == null) {
            return null;
        }
        // 2、从redis中查询登录用户
        String key = RedisTokenConstant.TOKEN_PREFIX + userId;
        return redisCache.getCacheObject(key);
    }

    /**
     * 存储登录用户，用户id作为key，示例：token:{userId} = {loginUser}
     * @param userId 用户id
     * @param loginUser 登录用户
     */
    public static void saveLoginUser(Long userId, YdlLoginUser loginUser, RedisCache redisCache) {
        String key = RedisTokenConstant.TOKEN_PREFIX + userId;
        redisCache.setCacheObject(key,loginUser,RedisTokenConstant.TOKEN_TIME, TimeUnit.SECONDS);
    }

}
```

### WebUtils

```java
public class WebUtils {
    /**
     * 将字符串渲染到客户端
     *
     * @param response 渲染对象
     * @param string   待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try {
            response.setStatus(200);
            response.setContentType("application/json");
            response.setCharacterEncoding("utf-8");
            response.getWriter().print(string);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

### JwtUtil

```java
@SuppressWarnings("WeakerAccess")
public class JwtUtil {
    /**
     * 秘钥
     * - 默认aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrsssttt
     */
    private static String secret = "aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrsssttt";
    /**
     * 有效期，单位秒
     * - 默认2周
     */
    private static Long ttlMillis = 1209600L;

    /**
     * 生成加密后的秘钥 secretKey
     * @return
     */
    public static SecretKey generalKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * 生成jwt
     * 私匙使用固定秘钥
     *
     * @param claims    设置的信息
     * @return
     */
    public static String createJwt(Map<String, Object> claims) {
        // 指定签名的时候使用的签名算法，也就是header那部分
//        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        // 生成JWT的时间
        long expMillis = System.currentTimeMillis() + ttlMillis * 1000;
        Date exp = new Date(expMillis);

        //生成 HMAC 密钥，根据提供的字节数组长度选择适当的 HMAC 算法，并返回相应的 SecretKey 对象。
        SecretKey key = generalKey();

        // 设置jwt的body
        JwtBuilder builder = Jwts.builder()
                // 设置签名使用的签名算法和签名使用的秘钥
                .signWith(key)
                // 就是一个map，存数据
                .claims(claims)
                // 设置过期时间
                .expiration(exp);
        return builder.compact();
    }

    /**
     * Token解密
     * @param token     加密后的token
     * @return
     */
    public static Claims parseJWT(String token) {

        //生成 HMAC 密钥，根据提供的字节数组长度选择适当的 HMAC 算法，并返回相应的 SecretKey 对象。
        SecretKey key = generalKey();

        // 得到DefaultJwtParser
        JwtParser jwtParser = Jwts.parser()
                // 设置签名的秘钥
                .verifyWith(key)
                .build();
        Jws<Claims> jws = jwtParser.parseSignedClaims(token);
        Claims claims = jws.getPayload();
        return claims;
    }

    public static void main(String[] args) {
//        JwtUtil jwtUtil = new JwtUtil();
//
//        SysUser sysUser = new SysUser();
//        sysUser.setId(1L);
//        sysUser.setUserName("itlils");
//        // 存一个map到jwt中
//        Map<String, Object> claims = new HashMap<>();
//        claims.put(JwtClaimsConstant.USER_ID,sysUser.getId());
//        claims.put(JwtClaimsConstant.USER_NAME,sysUser.getUserName());
//        String token = jwtUtil.createJwt(claims);
//        System.out.println(token);
//
//
//        Claims claims1 = jwtUtil.parseJWT(token);
//        //claims就是在Pyload中存放的用户信息
//        System.out.println("claims1.get(JwtClaimsConstant_USERNAME) = " + claims1.get(JwtClaimsConstant.USER_NAME));

    }

}
```

## resources

### application.yml

```yml
server:
  port: 8080
  servlet:
    context-path: /admin
    encoding:
      charset: utf-8
      force: true
      enabled: true
spring:
  application:
    name: spring-security
  datasource:
    url: jdbc:mysql://192.168.169.130:3306/activiti?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false&useServerPrepStmts=true&cachePrepStmts=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: Cirno760
  data:
    redis:
      port: 6380
      host: 192.168.169.130
  activiti:
    database-schema-update: true  # 开发时设置为true（自动创建表），生产时设置为false（检查数据库表的版本和依赖库的版本， 如果版本不匹配就抛出异常。）
    db-history-used: true
    history-level: full
    check-process-definitions: true # 检查resources/processes文件夹是否修改
mybatis-plus:
  configuration:
    log-prefix: mysql.sql.
    map-underscore-to-camel-case: true
    lazy-loading-enabled: true
    aggressive-lazy-loading: false
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
  type-aliases-package: com.ydlclass.activitidemo2.entity
  mapper-locations: classpath:mapper/**/*.xml
logging:
  config: classpath:logback.xml
```

### logback.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--  ========================================== custom ===============================================  -->
    <property name="log_dir" value="D://Java/code/logs"/>

    <Property name="appName" value="appName"/>
    <!--日志类型，推荐分类有 stats/monitor/visit-->
    <Property name="logType" value="monitor"/>

    <!--文件名字，代表日志描述-->
    <property name="info_file_name" value="sys-info"/>
    <property name="warn_file_name" value="sys-warn"/>
    <property name="error_file_name" value="sys-error"/>
    <property name="sql_file_name" value="mysql-sql"/>

    <property name="maxHistory" value="7"/>
    <!--  ========================================== default ===============================================  -->
    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />
    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />
    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />

    <property name="CONSOLE_LOG_PATTERN" value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(12712){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n%wEx"/>
    <property name="CONSOLE_LOG_CHARSET" value="UTF-8"/>
    <property name="FILE_LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %5p 12712 --- [%t] %-40.40logger{39} : %m%n%wEx"/>
    <property name="FILE_LOG_CHARSET" value="UTF-8"/>

    <logger name="org.apache.catalina.startup.DigesterFactory" level="ERROR"/>
    <logger name="org.apache.catalina.util.LifecycleBase" level="ERROR"/>
    <logger name="org.apache.coyote.http11.Http11NioProtocol" level="WARN"/>
    <logger name="org.apache.sshd.common.util.SecurityUtils" level="WARN"/>
    <logger name="org.apache.tomcat.util.net.NioSelectorPool" level="WARN"/>
    <logger name="org.eclipse.jetty.util.component.AbstractLifeCycle" level="ERROR"/>
    <logger name="org.hibernate.validator.internal.util.Version" level="WARN"/>
    <logger name="org.springframework.boot.actuate.endpoint.jmx" level="WARN"/>
    <!--  ========================================== default ===============================================  -->
    <property name="LOG_FILE" value="${log_dir}/${appName}_spring.log"/>
    <!--  ========================================== default ===============================================  -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>${CONSOLE_LOG_CHARSET}</charset>
        </encoder>
    </appender>
    <!--  ========================================== default ===============================================  -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${FILE_LOG_CHARSET}</charset>
        </encoder>
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>0</totalSizeCap>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
    </appender>
    <!--  ========================================== default ===============================================  -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
    <!--  ========================================== custom ===============================================  -->
    <appender name="FILE_CUSTOM_INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${FILE_LOG_CHARSET}</charset>
        </encoder>
        <file>${log_dir}/${appName}_${logType}_${info_file_name}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/${appName}_${logType}_${info_file_name}.log.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>0</totalSizeCap>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>info</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <appender name="FILE_CUSTOM_WARN" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${FILE_LOG_CHARSET}</charset>
        </encoder>
        <file>${log_dir}/${appName}_${logType}_${warn_file_name}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/${appName}_${logType}_${warn_file_name}.log.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>0</totalSizeCap>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>warn</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <appender name="FILE_CUSTOM_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${FILE_LOG_CHARSET}</charset>
        </encoder>
        <file>${log_dir}/${appName}_${logType}_${error_file_name}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/${appName}_${logType}_${error_file_name}.log.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>0</totalSizeCap>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>error</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <appender name="FILE_CUSTOM_SQL" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${FILE_LOG_CHARSET}</charset>
        </encoder>
        <file>${log_dir}/${appName}_${logType}_${sql_file_name}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/${appName}_${logType}_${sql_file_name}.log.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>0</totalSizeCap>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
    </appender>
    <appender name="FILE_CUSTOM_INFO_ASYN" class="ch.qos.logback.classic.AsyncAppender">
        <!--一个异步appender只能配一个-->
        <appender-ref ref="FILE_CUSTOM_INFO"/>
    </appender>
    <appender name="FILE_CUSTOM_WARN_ASYN" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE_CUSTOM_WARN"/>
    </appender>
    <appender name="FILE_CUSTOM_ERROR_ASYN" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE_CUSTOM_ERROR"/>
    </appender>
    <appender name="FILE_CUSTOM_SQL_ASYN" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE_CUSTOM_SQL"/>
    </appender>
    <logger name="com.ydlclass" level="info" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_CUSTOM_INFO_ASYN"/>
        <appender-ref ref="FILE_CUSTOM_WARN_ASYN"/>
        <appender-ref ref="FILE_CUSTOM_ERROR_ASYN"/>
    </logger>
    <!--有mybatis的情况下，可以单独把sql日志打到一个文件中，需要在mybatis中配置logPrefix-->
    <logger name="mysql.sql" level="info" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_CUSTOM_SQL_ASYN"/>
    </logger>

</configuration>
```